<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>The futurelearn application</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<h1>The futurelearn application</h1>
<p>This has been created by copying overview.edoc to README.md. Running <code>make doc</code> creates index.html which looks better.</p>

<h1>Pid Bang</h1>

<p>Thinking in terms of sending and receiving messages between listening loops rather than return values from functions with 
arguments I found a bit tricky.</p>

<p>Joe Armstrong in this youtube video</p>

<p><a href="https://www.youtube.com/watch?v=0jsdXFUvQKE&amp;list=PLR812eVbehlwq4qbqswOWH7NLKjodnTIn&amp;index=2">
https://www.youtube.com/watch?v=0jsdXFUvQKE&amp;list=PLR812eVbehlwq4qbqswOWH7NLKjodnTIn&amp;index=2</a></p>

<p>invokes the old Elvis song "Return to sender" as a handy reminder that 
<a href="https://erlang.org/doc/reference_manual/processes.html">processes</a> sending "arguments" (as messages) to
other processes need to provide a return address to get the result back in their mailbox. 
A process can simply give its return address as 
<a href="https://erlang.org/doc/man/erlang.html#self-0">self()</a>.</p>

<h2>Parallel Map</h2>

<p>In this youtube video</p>

<p><a href="https://www.youtube.com/watch?v=0jsdXFUvQKE&amp;list=PLR812eVbehlwq4qbqswOWH7NLKjodnTIn&amp;index=2">
https://www.youtube.com/watch?v=0jsdXFUvQKE&amp;list=PLR812eVbehlwq4qbqswOWH7NLKjodnTIn&amp;index=2</a></p>

<p>Joe Armstrong provides the following example (he left function F out of the argument list for pmap,
which I assume is a typo):</p>

<p><code><pre>
function pmap(F, L) -&gt;
  S = self(),
  Pids = [do(S, F) || F &lt;- L],
  [receive {Pid, Val} -&gt; Val end || Pid &lt;- Pids].

do(Parent, F) -&gt;
  spawn(fun() -&gt; Parent ! {self(), F()} end).
</pre></code></p>

<p>For a process created by <a href="https://erlang.org/doc/man/erlang.html#spawn-3">spawn(Module, Function, Args)</a>
to remain alive for repeated messages, it needs to be written as a <em>listening loop</em> that calls itself after handling a message.</p>

<p>Another tricky concept is the <a href="https://erlang.org/doc/reference_manual/expressions.html#receive">receive</a> 
block doesn't need to be in the process that makes the initial call, but can be in a subsidiary function.</p>

<h2>after Timeout -&gt; ...</h2>

<p>An important difference between Erlang and the Elvis song is if the <em>to address</em> is wrong
you won't get a bounceback saying <q>... address unknown. No such number, no such zone</q>, 
so care needs to be taken to avoid waiting at the mailbox for a response that will never come.</p>

<h1><a href="https://erlang.org/doc/reference_manual/errors.html">Error Handling</a></h1>

<p>This is a fairly complex topic, introducing several new primitives.</p>

<p>Erlang broadly has two ways of handling crashes: one suited for when the caller is a message handler with repeat ... end,
and another for traditional function calls using try ... catch ... end.</p>

<h2>Error propogation in a network of nodes</h2>

<p>The key BIFs here are <a href="https://erlang.org/doc/man/erlang.html#link-1">link(PidOrPort) -&gt; true</a> which links the
calling process to another, or 
<a href="https://erlang.org/doc/man/erlang.html#spawn_link-3">spawn_link(Module, Function, Args) -&gt; pid()</a>
which is safer when calling spawn since it does both as an atomic operation (avoding a race condition if the spawned process should
immediately die).</p>

<p>If the process spawning a child process is its <em>supervisor</em>, it needs to set
<a href="https://erlang.org/doc/man/erlang.html#process_flag-2">process_flag(trap_exit, true)</a>.</p>

<p>Otherwise, if <em>trap_exit</em> is left at the default <em>false</em>, linked processes are designed to fall like dominoes.</p>

<p>A node can kill itself with <a href="https://erlang.org/doc/man/erlang.html#exit-1">exit(Reason) -&gt; no_return()</a>, and nodes
can be killed externally by <a href="https://erlang.org/doc/man/erlang.html#exit-2">exit(Pid, Reason) -&gt; true</a></p>

<p>If the supervisor node has <em>trap_exit</em> set to <em>true</em>, instead of topling over it needs to handle a message
<code>{'EXIT', FromPid, Reason}</code>.</p>

<p>Reason can be any atom, but there's a little subtlety about <code>exit(kill)</code>: the linked process receives 
<code>{'EXIT', FromPid, killed}</code></p>

<p>This doesn't seem to apply other exit reasons like <em>normal</em> etc.</p>

<h2>Exceptions</h2>

<p>Usually, errors are handled by sending either <code>{ok, Value}</code> or <code>{error, Reason}</code> messages.</p>

<p>Only use these to exit deeply nested recursion as in parsers.</p>

<p>There are three types of exceptions, each of which creates a different Class for catch:</p>

<p><code><pre>
try Expr
catch
    throw:Term -&gt; Term;
    exit:Reason -&gt; {'EXIT', Reason}
    error:Reason:Stk -&gt; {'EXIT', {Reason, Stk}}
end
</pre></code></p>

<dl>
  <dd><a href="https://erlang.org/doc/man/erlang.html#exit-2">exit(Pid, Reason) -&gt; true</a> or 
      <a href="https://erlang.org/doc/man/erlang.html#exit-1">exit(Reason) -&gt; no_return()</a>
  </dd>
  <dt>Used with <a href="https://erlang.org/doc/man/erlang.html#link-1">link(PidOrPort) -&gt; true</a>
      and <a href="https://erlang.org/doc/man/erlang.html#process_flag-2">process_flag(trap_exit, true)</a>
      to convert exit signals into <code>{'ERROR', From, Reason}</code> message.
  </dt>
  <dd><a href="https://erlang.org/doc/man/erlang.html#throw-1">throw(Any) -&gt; no_return()</a></dd>
  <dt>Used with <a href="https://erlang.org/doc/reference_manual/expressions.html#catch-and-throw">catch</a> expressions
      which can be enhanced with <a href="https://erlang.org/doc/reference_manual/expressions.html#try">try</a>
  </dt>
  <dd><a href="https://erlang.org/doc/man/erlang.html#error-1">error(Reason) -&gt; no_return()</a></dd>
  <dt>Includes stack trace for debugging</dt>
</dl>

<p><code><pre>
eval(Env, {div, Num, Denom}) -&gt;
  N = eval(Env, Num),
  D = eval(Env, Denom),
  case D of
    0   -&gt; throw(div_by_zero);
    _NZ -&gt; N div D
  end;

try eval(Env, Exp) of
  Res -&gt; Res
catch
  throw:div_by_zero -&gt; 0
end
</pre></code></p>


<p>https://s3.us-east-2.amazonaws.com/ferd.erlang-in-anger/text.v1.1.0.pdf</p>


<p>http://erlang.org/doc/apps/observer/observer_ug.html</p>

<p>https://github.com/RefactoringTools/percept2</p>

<p>https://concuerror.com/</p>

<p>https://dl.acm.org/doi/10.1145/1596550.1596574</p>



<hr>
<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
